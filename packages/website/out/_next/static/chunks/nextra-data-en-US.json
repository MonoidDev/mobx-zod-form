{"/":{"title":"Introduction","data":{"":"","what-is-mobx-zod-form#What is Mobx Zod Form?":"Mobx Zod Form is a data-first form builder based on two amazing libraries: mobx and zod.You first define your form in zod:\nimport { MobxZodField } from \"@monoid-dev/mobx-zod-form\";\nimport { z, ZodNumber, ZodString } from \"zod\";\n\n// Necessary step to setup zod with mobx-zod-form power!\nextendZodWithMobxZodForm(z);\n\nconst Form = () => {\nconst form = useForm(\nz.object({\nusername: z.string().min(1),\npassword: z.string().min(6),\n}),\n);\n\n// ...\n};\nDefine your field controller component:\nimport { observer } from \"mobx-react\";\n\nconst TextInput = observer(\n({ field }: { field: MobxZodField<ZodString | ZodNumber> }) => {\nreturn (\n<div>\n<input\nplaceholder={field.path.at(-1)?.toString()}\nvalue={field.rawInput as string}\nonChange={(e) => field.setRawInput(e.target.value)}\n/>\n{field.errorMessages.map((e, i) => (\n<div style={{ color: \"red\" }} key={i}>\n{e}\n</div>\n))}\n</div>\n);\n},\n);\nConnect your form to your field controllers:\nconst Form = () => {\nconst form = useForm(\nz.object({\nusername: z.string().min(1),\npassword: z.string().min(6),\n}),\n);\n\nreturn (\n<form style={{ border: `1px solid black` }}>\n<TextInput field={form.root.fields.username} />\n<TextInput field={form.root.fields.password} />\n<button\nonClick={() => {\nform.handleSubmit(() => console.info(form.parsed));\n}}\n>\nSubmit\n</button>\n</form>\n);\n};\nThen you just created an end-to-end safe form widget!","how-is-mobx-zod-form-different-from-other-libs#How is Mobx Zod Form different from other libs?":"","no-magic-strings#No magic-strings":"Some libraries, like formik and react-final-form, force user to use the path to the field to connect the field with the input:\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Formik, Field, Form } from 'formik';\n\nconst Basic = () => (\n<div>\n<h1>Sign Up</h1>\n<Formik\ninitialValues={{\nfirstName: '',\nlastName: '',\nemail: '',\n}}\nonSubmit={async (values) => {\nawait new Promise((r) => setTimeout(r, 500));\nalert(JSON.stringify(values, null, 2));\n}}\n>\n<Form>\n<label htmlFor=\"firstName\">First Name</label>\n<Field id=\"firstName\" name=\"firstName\" placeholder=\"Jane\" />\n\n<label htmlFor=\"lastName\">Last Name</label>\n<Field id=\"lastName\" name=\"lastName\" placeholder=\"Doe\" />\n\n<label htmlFor=\"email\">Email</label>\n<Field\nid=\"email\"\nname=\"email\"\nplaceholder=\"jane@acme.com\"\ntype=\"email\"\n/>\n<button type=\"submit\">Submit</button>\n</Form>\n</Formik>\n</div>\n);\n\nReactDOM.render(<Basic />, document.getElementById('root'));\nAlthough they entitle them as supporting TypeScript, the following code is not really type-safe:\n<Field id=\"firstName\" name=\"firstName\" placeholder=\"Jane\" />\n<Field id=\"lastName\" name=\"lastName\" placeholder=\"Doe\" />\nNot only does the user need to write id=\"firstName\" and name=\"firstName\" with the same \"firstName\" twice, but also the user does this with NO type-checks. For a form with a handful of fields, that might be just convenient enough, but our experience of maintaining a huge number of forms proves this not really feasible.","decode-not-raw-data#Decode, not raw data.":"Libraries like formik gives the parsing and validation part away to the user, which could be quite a burden as the form gets complex.\n<Formik\ninitialValues={{\nname: '',\nage: '',\n}}\nvalidate={(values) => {\nconst errors = {};\nif (Number.isNaN(Number.parseInt(values.age))) {\nerrors.age = 'Please input a valid age';\n}\nreturn errors;\n}}\nonSubmit={(values) => {\nconst ageParsed = Number.parseInt(values.age);\n// ...\n}}\n>\n// ...\n</Formik>\nBecause the fact that <input /> doesn't really give us a number, but gives us a number encoded in a decimal format string, we are passed with values.age as a string everywhere. We need to handle it both in validate and onSubmit, which brings trouble.In Mobx Zod Form, we first decode the form, casting any number-like string to number against our schema, then you have the digested value from field.decodeResult.data, as illustrated below:\nconst FormDecode = () => {\nconst fields = useForm(\nz.object({\nname: z.string().min(1),\nage: z.number(),\n}),\n).root.fields;\n\nif (fields.age.decodeResult.success) {\nconsole.info(\"Age is:\", fields.age.decodeResult.data); // <-- number, not string\n}\n\nreturn (\n<form style={{ border: `1px solid black` }}>\n<TextInput field={fields.name} />\n<TextInput field={fields.age} />\n</form>\n);\n};\n\nNotice that in a cruel world, the decoding might fail. So decodeResult is actually a discriminated union with success: true only when the input is valid.","compose-out-of-the-box#Compose, out of the box.":"Consider you have a credit card info input, which you might use it a couple of times in the UI:\nconst CreditCardSchema = z.object({\ncardNumber: z.string().min(1),\nsecureCode: z.string().min(1),\nexpirationMonth: z.number().min(1).max(12),\nexpirationYear: z.number().min(new Date().getFullYear()).max(9999),\n});\n\ntype CreditCardSchema = z.infer<typeof CreditCardSchema>;\n\nconst CreditCardInput = (props: {\nfield: MobxZodObjectField<typeof CreditCardSchema>;\n}) => {\nconst {\nfield: { fields },\n} = props;\n\nreturn (\n<div style={{ border: \"1px solid red\" }}>\n<div>Input your card info:</div>\n<TextInput field={fields.cardNumber} />\n<TextInput field={fields.secureCode} />\n<TextInput field={fields.expirationMonth} />\n<TextInput field={fields.expirationYear} />\n</div>\n);\n};\nNow you can plug CreditCardSchema else where, and then bind the corresponding field to CreditCardInput:\nconst ComposableForm = () => {\nconst fields = useForm(\nz.object({\nbookName: z.string().min(1),\ncreditCard: CreditCardSchema,\n}),\n).root.fields;\n\nreturn (\n<div style={{ border: `1px solid black` }}>\n<TextInput field={fields.bookName} />\n<CreditCardInput field={fields.creditCard} />\n</div>\n);\n};\nThe entire process is, of course, as type-checked as guaranteed.Consider that you are using formik, you might need to write the following component:\nconst CreditCardInput = ({ name }: { name: string }) => {\nreturn (\n<>\n<Field id={`${name}.cardNumber`} id={`${name}.cardNumber`} placeholder=\"0000123456781234\" />\n<Field id={`${name}.secureCode`} id={`${name}.secureCode`} placeholder=\"123\" />\n<Field id={`${name}.expirationMonth`} id={`${name}.expirationMonth`} placeholder=\"123\" />\n<Field id={`${name}.expirationYear`} id={`${name}.expirationYear`} placeholder=\"2024\" />\n</>\n);\n};\nNot only does this needs a lot of template strings, but also it just doesn't handle the repeated validation logic! I will leave how to do that in formik or react-final-form as your homework :)"}}}